## Klerk Rubricator

### Тестовое задание Klerk

### Установка

Скачать проект (автоматически создаст папку "klerk-rubricator").

```
git clone https://github.com/gukihuman/klerk-rubricator.git
```

Перейти в папку проекта, поставить зависимости и запустить dev сервер:

```
cd klerk-rubricator
npm install
npm run dev
```

Открыть http://localhost:3000/ в браузере.

#### Заметки

-   Оставил в консоли вывод полученных данных для удобства проверки задания. В работе такой вывод данных был бы удален изначально.
-   Комментарии в коде на английском, потому что так привык. В работе, разумеется, буду соблюдать принятую в проекте стилистику.
-   Возник вопрос по поводу вывода суммы count'ов для родительской категории "Рубрики". Напрямую об этом не сказано, но я ришил добавить. Отвлекать на такую мелочь в рамках тех. задания не стал. В работе бы спросил в процессе выполнения.
-   Добавил API server-side обработчик, который принимает данные с основного API через обычную fetch функцию. Причина - неизвесная ошибка $fetch в продакшене на CodeSandbox, StackBlitz и Vercel (на dev сервере все в порядке).Другие API работают без проблем. Есть подозрение, что в нашей API нехватает каких-то headers и это связано с CORS. На углубление в понимание проблемы потребуется время. С другой стороны, собственный server-side обработчик на фронтенде работает нормально и можно работать с ним, если нет необходимости иметь статичный build.

#### Выбор между вложенным v-for и рекурсивным компонентом RubricLayer

Интересный выбор, с которым я столкнулся - использовать ли рекурсивный компонент для представления индивидуального слоя рубрик или просто использовать вложенный v-for несколько раз. Использование вложенного v-for потребовало бы установления некоторых ограничений для бэкенда: фронтенд может обрабатывать только до, например, 3-ех вложенных уровней, а хотелось бы, чтобы фронтенд представлял собой надежную архитектуру, способную стабильно обрабатывать данные с API, даже если в будущем появятся дополнительные вложенные уровни рубрик. Решил использовать рекурсивный компонент RubricLayer, который представляет индивидуальный слой рубрик и вызывает сам себя для дочерних рубрик. Можно было бы объединить с основным компонентом Rubricator, но это привело бы к нагромождению кода: пришлось бы добавлять динамический параметр isRoot и на него привязывать различия в template. Конечно появляется дополнительный компонент, который не инкапсулирован, но документация должна решить эту проблему. Конечно, в идеале бы не создавать лишних компонентов, и я бы предложил руководителю сделать один компонент с чуть более сложным внутренним кодом, если так удобнее.

#### Потенциальные возможные улучшения

-   Можно сделать анимацию для суммы выбранных рубрик, когда они меняются: сам счетчик растет или уменьшается. Конечно, она не должна быть долгой, не больше 100 мс.
-   Вместо $fetch в Nuxt 3 можно использовать useFetch() - лучше и надежнее контролирует состояния API запросов. В небольшом тех. задании решил не усложнять, тем более, как мне сообщили, основной проект компании написан на Nuxt 2.
